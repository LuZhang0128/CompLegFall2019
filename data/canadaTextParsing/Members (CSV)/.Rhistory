<<<<<<< HEAD
select(name))
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
qplot(top_names_2017, babynames$prop, babynames)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
select(name == "Emma"|| name == "Olivia" || name == "Liam" || name == "Noah")
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
select( name == "Emma"|| name == "Olivia" || name == "Liam" || name == "Noah")
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
filter( name == "Emma"|| name == "Olivia" || name == "Liam" || name == "Noah")
View(x)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
top_n(4) %>%
select(name))
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
top_n(4) %>%
select(name)
x <- babynames %>%
filter(year == 2017) %>%
top_n(4) %>%
select(prop)
View(x)
y <- babynames %>%
filter(year == 2017) %>%
top_n(4) %>%
select(prop)
x <- babynames %>%
filter(year == 2017) %>%
top_n(4)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
select(name， 1:4)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
x <- babynames %>%
filter(year == 2017) %>%
select(name, 1:4)
x <- babynames %>%
filter(year == 2017) %>%
select(name, 1:4)
View(x)
top_names <- babynames %>%
filter(!name %in% top_names_2017)
View(top_names)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
filter(name %in% top_names_2017)
View(y)
View(top_names)
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4) %>%
select(name))
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(n,4) %>%
select(name))
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(prop,4) %>%
select(name))
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, prop) %>%
select(name))
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name))
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
filter(name %in% c("Emma","Olivia"))
View(y)
library(babynames)
library(tidyverse)
library(gapminder)
# For the year 2017, find the most common name among females.
babynames %>%
filter(year == 2017) %>%
filter(sex == "F" ) %>%
arrange(desc(n))
# For the year 1982, find the number of males.
babynames %>%
filter(year == 1982) %>%
count(sex == "M")
# For each year, find the number of distinct male and female names given in that year.
babynames %>%
group_by(year) %>%
distinct(name) %>%
count()
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name))
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
filter(name %in% c("Emma","Olivia"))
qplot(, , )
View(top_names)
filter(name %in% c("Emma","Olivia","Liam","Noah"))
top_names <- babynames %>%
group_by(year)
filter(name %in% c("Emma","Olivia","Liam","Noah"))
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% c("Emma","Olivia","Liam","Noah"))
View(top_names)
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% c("Emma","Olivia","Liam","Noah"))
babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% top_names_2017)
qplot(year, prop, top_names, color=name)
qplot(year, prop, data = top_names, geom = 'line', color = name)
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% top_names_2017)
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% c("Emma","Olivia","Liam","Noah"))
qplot(year, prop, data = top_names, geom = 'line', color = name)
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name)
<-c("Emma","Olivia","Liam","Noah"))
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name) %>%
c("Emma","Olivia","Liam","Noah"))
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name)
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name))
# Find the four most given names in 2017 (across both sexes). Store these four names into a character vector and call that vector top_names_2017
top_names_2017 <- as.character(babynames %>%
filter(year == 2017) %>%
top_n(4, n) %>%
select(name) )
# Use a line graph to display the evolution through time of the proportion of all given names that correspond to one of these four names (one line per name).
top_names <- babynames %>%
group_by(year) %>%
filter(name %in% c("Emma","Olivia","Liam","Noah"))
qplot(year, prop, data = top_clean_names, geom = 'line', color = name)
# The sudden drops in the previous graph come from the fact that it depicts two observations for each year. For each name, the graph represents the number of females and males who were given the name. (Each name is predominantly given to people of a given sex. Unusual name assignments may be part intential, and part results of errors in recording people’s sexes)
top_clean_names <- top_names %>%
filter(prop > 0.0002)
qplot(year, prop, data = top_clean_names, geom = 'line', color = name)
canada_commons_members_parl42 <- read.csv("~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)/canada_commons_members_parl42.csv", comment.char="#")
View(canada_commons_members_parl42)
# TODO: raw data
df_aa <- merge(x=df_b,y=canada_members_updated ,by="full_name",all.x=TRUE) %>%
select(observation_path,
parliament_number,
chamber_path,
observation_number,
parliament_number,
chamber_number,
chamber_name,
full_name,
first_name.x,
last_name.x,
constituency_name,
constituency_path,
start_date,
end_date) %>%
distinct()
#######################
=======
df$party_name[df$party_name == "Conservative"] <- "Conservative Party of Canada"
df$party_name[df$party_name == "Liberal"] <- "Liberal Party of Canada"
df$party_name[df$party_name == "NDP"] <- "New Democratic Party"
df$party_name[df$party_name == "Green Party"] <- "Green Party of Canada"
# fix constituency name
df$constituency_name[df$constituency_name == "Western Arctic"] <- "Northwest Territories"
# drop title
df$title <- NULL
# chamber name
df$chamber_name <- "House of Commons"
# full name
df$full_name <- str_c(df$first_name, df$last_name, sep = " ")
# drop those observations missing first names
df <-  filter(df, first_name != "")
return(df)
}
allMPs <- cleanDates(allMPs, "start_date", "end_date")
View(allMPs)
# INPUT:
# (1) data frame that dates are in
# (2) name of column with start dates (start_date)
# (3) name of column with end dates (end_date)
# OUTPUT:
# start_year, start_month, start_day
# end_year, end_month, end_day
cleanDates <- function(df, start, end){
# remove timestamp from string
# removing leading "20" in some year dates
# converting all to prefered date object and format
browser()
df[,start] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start])), "%m/%d/%y")
df[,end] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,end])), "%m/%d/%y")
# clean party names
df$party_name[df$party_name == "Conservative"] <- "Conservative Party of Canada"
df$party_name[df$party_name == "Liberal"] <- "Liberal Party of Canada"
df$party_name[df$party_name == "NDP"] <- "New Democratic Party"
df$party_name[df$party_name == "Green Party"] <- "Green Party of Canada"
# fix constituency name
df$constituency_name[df$constituency_name == "Western Arctic"] <- "Northwest Territories"
# drop title
df$title <- NULL
# chamber name
df$chamber_name <- "House of Commons"
# full name
df$full_name <- str_c(df$first_name, df$last_name, sep = " ")
# drop those observations missing first names
df <-  filter(df, first_name != "")
return(df)
}
allMPs <- cleanDates(allMPs, "start_date", "end_date")
df[,start]
sort(  df[,start])
rev(sort(  df[,start]))
gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start]))
as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start])), "%m/%d/%y")
gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start]))
# INPUT:
# (1) data frame that dates are in
# (2) name of column with start dates (start_date)
# (3) name of column with end dates (end_date)
# OUTPUT:
# start_year, start_month, start_day
# end_year, end_month, end_day
cleanDates <- function(df, start, end){
# remove timestamp from string
# removing leading "20" in some year dates
# converting all to prefered date object and format
#browser()
df[,start] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start])), "%m/%d/%y")
df[,end] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,end])), "%m/%d/%y")
# clean party names
df$party_name[df$party_name == "Conservative"] <- "Conservative Party of Canada"
df$party_name[df$party_name == "Liberal"] <- "Liberal Party of Canada"
df$party_name[df$party_name == "NDP"] <- "New Democratic Party"
df$party_name[df$party_name == "Green Party"] <- "Green Party of Canada"
# fix constituency name
df$constituency_name[df$constituency_name == "Western Arctic"] <- "Northwest Territories"
# drop title
df$title <- NULL
# chamber name
df$chamber_name <- "House of Commons"
# full name
df$full_name <- str_c(df$first_name, df$last_name, sep = " ")
# drop those observations missing first names
df <-  filter(df, first_name != "")
return(df)
}
allMPs <- cleanDates(allMPs, "start_date", "end_date")
View(allMPs)
######################
>>>>>>> 112f3ac1f919f70c40930d77734580282309686d
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
package.list <- setdiff(package.list,basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
<<<<<<< HEAD
=======
# execute function to keep only basic
# packages in global envir.
>>>>>>> 112f3ac1f919f70c40930d77734580282309686d
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
lapply(c("stringr", "dplyr", "plyr", "tidyverse", "rvest", "zoo"), pkgTest)
#####################
# read in data
#####################
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/')
canada_chamber_membership <- read.csv("canada_chamber_membership.csv", encoding="UTF-8")
canada_constituencies <- read.csv("canada_constituencies.csv", encoding="UTF-8")
canada_members <- read.csv("canada_members.csv", encoding="UTF-8")
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)')
file_names <- list.files(pattern="*.csv", full.names=TRUE, recursive=FALSE)
df <- do.call(rbind, lapply(file_names, function(x) cbind(read.csv(x,encoding="UTF-8",na.strings=c("", "NA")), parliament_number=strsplit(x,'_|\\.')[[1]][5])))
##############################
# update constituencies
##############################
# import data
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)')
canada_commons_members_parl42 <- read.csv("canada_commons_members_parl42.csv", encoding="UTF-8")
# update the dataframe, sort by constituency_name
colnames(canada_commons_members_parl42)[which(names(canada_commons_members_parl42) == "Province...Territory")] <- "province_name"
colnames(canada_commons_members_parl42)[which(names(canada_commons_members_parl42) == "Constituency")] <- "constituency_name"
updated <- merge(canada_constituencies,canada_commons_members_parl42,by=c("constituency_name","province_name"),all=TRUE) %>%
distinct()
#canada_constituencies_updated <- updated[order(updated$constituency_name)]
sorted_name <- sort(updated$constituency_name)
name <- data.frame(sorted_name)
canada_constituencies_updated <- merge(x=updated,y=name,by.x="constituency_name",by.y="sorted_name",all.y=TRUE) %>%
select(constituency_name,
observation_path,
chamber_path,
constituency_path,
observation_number,
chamber_number,
constituency_number,
chamber_name,
province_name) %>%
distinct()
# clean the dataframe
colnames(canada_constituencies_updated)
canada_constituencies_updated$observation_number <- as.numeric(rownames(canada_constituencies_updated))
canada_constituencies_updated$chamber_number <- 1
canada_constituencies_updated$constituency_number <- as.numeric(rownames(canada_constituencies_updated))
canada_constituencies_updated$chamber_name <- "House of Commons"
canada_constituencies_updated$chamber_path <- paste("/chamber-",canada_constituencies_updated$chamber_number,sep="")
canada_constituencies_updated$constituency_path <- paste(canada_constituencies_updated$chamber_path,"/constituency-",canada_constituencies_updated$constituency_number,sep="")
canada_constituencies_updated$observation_path <- paste(canada_constituencies_updated$chamber_path,"/observation-",canada_constituencies_updated$observation_number,sep="")
#######################
# member
#######################
# change column names
colnames(df) <- c("honorific_title","first_name","last_name","constituency_name","province_name","political_affiliation","start_date","end_date","parliament_number")
# drop all the empty rows and set full name
df<-df[!is.na(df$first_name),]
df$full_name <- paste(df$first_name, df$last_name, sep=" ")
# set start and end date to date format
df_a <- df %>%
separate(start_date, c("month", "day","year",NA), sep = "/| ") %>%
separate(parliament_number, c(NA,"parliament_number"), sep="l")
df_a$start_date <- as.Date(paste(df_a$year,df_a$month,df_a$day,sep="-"))
df_b <- df_a %>%
separate(end_date, c("month", "day","year",NA), sep = "/| ")
df_b$end_date <- as.Date(paste(df_b$year,df_b$month,df_b$day,sep="-"))
df_b$end_date[is.na(df_b$end_date)] <- as.Date("2019-09-11")
# merge with constituency
df_c <- merge(x=df_b,y=canada_constituencies_updated,by="constituency_name",all.x=TRUE) %>%
select(observation_path,
chamber_path,
observation_number,
chamber_number,
chamber_name,
full_name,
first_name,
last_name,
constituency_name,
constituency_path,
start_date,
end_date) %>%
distinct()
# select the correct start and end date
df_d <- df_c %>%
group_by(full_name) %>%
slice(which.min(start_date)) %>%
distinct()
df_e <- df_c %>%
group_by(full_name) %>%
slice(which.max(end_date)) %>%
distinct()
df_e$start_date <- df_d$start_date
# sort member by last name, first name, and constituency name
df_g <- df_e[order(df_e$last_name,df_e$first_name,df_e$constituency_name),]
df_g$member_number <- rownames(df_g)
df_g$member_path <- paste(df_g$chamber_path,"/member-",df_g$member_number,sep="")
# update observation path, observation number, party name, and constituency ID
df_g$observation_path <- paste(df_g$chamber_path,"/member-",df_g$member_number,sep="")
colnames(df_g)[which(names(df_g) == "constituency_path")] <- "constituency_ID"
df_g$observation_number <- rownames(df_g)
df_g$party_name <- NA
########### missing party name!! #################
################ Is constituency_ID the same as constituency_path?
##################################################
canada_members_updated <- df_g[c("observation_path",
"chamber_path",
"member_path",
"observation_number",
"chamber_number",
"member_number",
"chamber_name",
"full_name",
"first_name",
"last_name",
"constituency_name",
"constituency_ID",
"party_name",
"start_date",
"end_date")]
#######################
# membership
#######################
# TODO: raw data
df_aa <- merge(x=df_b,y=canada_members_updated ,by="full_name",all.x=TRUE) %>%
select(observation_path,
parliament_number,
chamber_path,
observation_number,
parliament_number,
chamber_number,
chamber_name,
full_name,
first_name.x,
last_name.x,
constituency_name,
constituency_path,
start_date,
end_date) %>%
distinct()
View(df)
View(canada_constituencies_updated)
#######################
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
basic.packages <- c("package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","package:base")
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
package.list <- setdiff(package.list,basic.packages)
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
<<<<<<< HEAD
detachAllPackages()
# load libraries
pkgTest <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
lapply(c("stringr", "dplyr", "plyr", "tidyverse", "rvest", "zoo"), pkgTest)
#####################
# read in data
#####################
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/')
canada_chamber_membership <- read.csv("canada_chamber_membership.csv", encoding="UTF-8")
canada_constituencies <- read.csv("canada_constituencies.csv", encoding="UTF-8")
canada_members <- read.csv("canada_members.csv", encoding="UTF-8")
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)')
file_names <- list.files(pattern="*.csv", full.names=TRUE, recursive=FALSE)
df <- do.call(rbind, lapply(file_names, function(x) cbind(read.csv(x,encoding="UTF-8",na.strings=c("", "NA")), parliament_number=strsplit(x,'_|\\.')[[1]][5])))
##############################
# update constituencies
##############################
# import data
setwd('~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)')
canada_commons_members_parl42 <- read.csv("canada_commons_members_parl42.csv", encoding="UTF-8")
# update the dataframe, sort by constituency_name
colnames(canada_commons_members_parl42)[which(names(canada_commons_members_parl42) == "Province...Territory")] <- "province_name"
colnames(canada_commons_members_parl42)[which(names(canada_commons_members_parl42) == "Constituency")] <- "constituency_name"
updated <- merge(canada_constituencies,canada_commons_members_parl42,by=c("constituency_name","province_name"),all=TRUE) %>%
distinct()
#canada_constituencies_updated <- updated[order(updated$constituency_name)]
sorted_name <- sort(updated$constituency_name)
name <- data.frame(sorted_name)
canada_constituencies_updated <- merge(x=updated,y=name,by.x="constituency_name",by.y="sorted_name",all.y=TRUE) %>%
select(constituency_name,
observation_path,
chamber_path,
constituency_path,
observation_number,
chamber_number,
constituency_number,
chamber_name,
province_name) %>%
distinct()
# clean the dataframe
colnames(canada_constituencies_updated)
canada_constituencies_updated$observation_number <- as.numeric(rownames(canada_constituencies_updated))
canada_constituencies_updated$chamber_number <- 1
canada_constituencies_updated$constituency_number <- as.numeric(rownames(canada_constituencies_updated))
canada_constituencies_updated$chamber_name <- "House of Commons"
canada_constituencies_updated$chamber_path <- paste("/chamber-",canada_constituencies_updated$chamber_number,sep="")
canada_constituencies_updated$constituency_path <- paste(canada_constituencies_updated$chamber_path,"/constituency-",canada_constituencies_updated$constituency_number,sep="")
canada_constituencies_updated$observation_path <- paste(canada_constituencies_updated$chamber_path,"/observation-",canada_constituencies_updated$observation_number,sep="")
#######################
# member
#######################
# change column names
colnames(df) <- c("honorific_title","first_name","last_name","constituency_name","province_name","political_affiliation","start_date","end_date","parliament_number")
# drop all the empty rows and set full name
df<-df[!is.na(df$first_name),]
df$full_name <- paste(df$first_name, df$last_name, sep=" ")
# set start and end date to date format
df_a <- df %>%
separate(start_date, c("month", "day","year",NA), sep = "/| ") %>%
separate(parliament_number, c(NA,"parliament_number"), sep="l")
df_a$start_date <- as.Date(paste(df_a$year,df_a$month,df_a$day,sep="-"))
df_b <- df_a %>%
separate(end_date, c("month", "day","year",NA), sep = "/| ")
df_b$end_date <- as.Date(paste(df_b$year,df_b$month,df_b$day,sep="-"))
df_b$end_date[is.na(df_b$end_date)] <- as.Date("2019-09-11")
# merge with constituency
df_c <- merge(x=df_b,y=canada_constituencies_updated,by="constituency_name",all.x=TRUE) %>%
select(observation_path,
chamber_path,
observation_number,
chamber_number,
chamber_name,
full_name,
first_name,
last_name,
constituency_name,
constituency_path,
start_date,
end_date) %>%
distinct()
# select the correct start and end date
df_d <- df_c %>%
group_by(full_name) %>%
slice(which.min(start_date)) %>%
distinct()
df_e <- df_c %>%
group_by(full_name) %>%
slice(which.max(end_date)) %>%
distinct()
df_e$start_date <- df_d$start_date
# sort member by last name, first name, and constituency name
df_g <- df_e[order(df_e$last_name,df_e$first_name,df_e$constituency_name),]
df_g$member_number <- rownames(df_g)
df_g$member_path <- paste(df_g$chamber_path,"/member-",df_g$member_number,sep="")
# update observation path, observation number, party name, and constituency ID
df_g$observation_path <- paste(df_g$chamber_path,"/member-",df_g$member_number,sep="")
colnames(df_g)[which(names(df_g) == "constituency_path")] <- "constituency_ID"
df_g$observation_number <- rownames(df_g)
df_g$party_name <- NA
########### missing party name!! #################
################ Is constituency_ID the same as constituency_path?
##################################################
canada_members_updated <- df_g[c("observation_path",
"chamber_path",
"member_path",
"observation_number",
"chamber_number",
"member_number",
"chamber_name",
"full_name",
"first_name",
"last_name",
"constituency_name",
"constituency_ID",
"party_name",
"start_date",
"end_date")]
#######################
# membership
#######################
# TODO: raw data
df_aa <- merge(x=df_b,y=canada_members_updated ,by="full_name",all.x=TRUE) %>%
select(observation_path,
parliament_number,
chamber_path,
observation_number,
parliament_number,
chamber_number,
chamber_name,
full_name,
first_name.x,
last_name.x,
constituency_name,
constituency_path,
start_date,
end_date) %>%
distinct()
View(canada_commons_members_parl42)
View(canada_constituencies_updated)
View(canada_members_updated)
=======
################################
# load dataset of constituencies
################################
# you'll want this later to merge w/ info from MPs
constituencies <- read.csv("../canada_constituencies.csv", stringsAsFactors = F, encoding = "UTF-8")
########################################
# distinguish b/w parliamentary sessions
########################################
# create a variable denoting which parliamentary session each dataframe is
# this is useful for when we combine the dataframes together by stacking
# them on top of each other by row (see line 89)
# first, create function to go over each dataframe
findNumber <- function(df){
# and grab any numbers in the name of that dataframe
# create that variable and apply value for each row
df$parliamentNumber <- gsub("[^[:digit:].]", "", i)
# return data frame
return(df)
}
# find all data frames in the global environment
globalEnvir <- .GlobalEnv
# iterate over all those data frame
for(i in filenames){
# apply function to each data frame in global environment
globalEnvir[[i]] <- findNumber(globalEnvir[[i]])
}
# can always check to make sure it worked
# ex; look at canada_commons_members_parl40$parliamentNumber
#############################
# create one large dataframe
#############################
# stack dataframes on top of each other
# to create one large dataframe
allMPs <- do.call(rbind, mget(filenames))
###################################
### clean names, dates, and parties
###################################
# rename variables to match codebook
names(allMPs) <- c("title", "first_name", "last_name", "constituency_name",
"province_name", "party_name", "start_date", "end_date", "parliament_number")
# INPUT:
# (1) data frame that dates are in
# (2) name of column with start dates (start_date)
# (3) name of column with end dates (end_date)
# OUTPUT:
# start_year, start_month, start_day
# end_year, end_month, end_day
cleanDates <- function(df, start, end){
# remove timestamp from string
# removing leading "20" in some year dates
# converting all to prefered date object and format
#browser()
df[,start] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start])), "%m/%d/%y")
df[,end] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,end])), "%m/%d/%y")
# clean party names
df$party_name[df$party_name == "Conservative"] <- "Conservative Party of Canada"
df$party_name[df$party_name == "Liberal"] <- "Liberal Party of Canada"
df$party_name[df$party_name == "NDP"] <- "New Democratic Party"
df$party_name[df$party_name == "Green Party"] <- "Green Party of Canada"
# fix constituency name
df$constituency_name[df$constituency_name == "Western Arctic"] <- "Northwest Territories"
# drop title
df$title <- NULL
# chamber name
df$chamber_name <- "House of Commons"
# full name
df$full_name <- str_c(df$first_name, df$last_name, sep = " ")
# drop those observations missing first names
df <-  filter(df, first_name != "")
return(df)
}
allMPs <- cleanDates(allMPs, "start_date", "end_date")
View(allMPs)
View(canada_commons_members_parl42)
View(canada_commons_members_parl42)
unique(canada_commons_members_parl42$Constituency)
sort(unique(canada_commons_members_parl42$Constituency))
sort(unique(canada_commons_members_parl39$Constituency))
######################
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
# create list of basic libraries that are essential
basic.packages <- c("package:stats","package:graphics","package:grDevices",
"package:utils","package:datasets","package:methods","package:base")
# find all packages that are floating in the global environment
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
# make sure that basic packages aren't dropped
package.list <- setdiff(package.list,basic.packages)
# remove all extra packages
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
# execute function to keep only basic
# packages in global envir.
detachAllPackages()
# set working directory
# which should be the same for everyone
# assuming GitHub is in your "Documents" folder
setwd("~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)/")
# load libraries
pkgTest <- function(pkg){
# check whether a package is installed
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
# if there are any packeages that need to be installed
if (length(new.pkg))
# install package
install.packages(new.pkg, dependencies = TRUE)
# and then load all packages user listed
sapply(pkg, require, character.only = TRUE)
}
# apply function to load libraries and install them if necessary
lapply(c("stringr", "plyr", "tidyverse", "tidyr", "dplyr"), pkgTest)
#######################
# load dataset of MPs
#######################
# read in your .csv files
# first, check which files are in the working directory
filenames <- gsub("\\.csv$","", list.files(pattern="\\.csv$"))
# iterate over those file names and read each .csv
for(i in filenames){
# Tip: you almost always want to read stringsAsFactors=F in .csv
# because you want to often text as text, not factors
assign(i, read.csv(paste(i, ".csv", sep=""), stringsAsFactors = F, encoding = "UTF-8"))
}
View(canada_commons_members_parl42)
View(canada_commons_members_parl41)
#######################
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
# create list of basic libraries that are essential
basic.packages <- c("package:stats","package:graphics","package:grDevices",
"package:utils","package:datasets","package:methods","package:base")
# find all packages that are floating in the global environment
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
# make sure that basic packages aren't dropped
package.list <- setdiff(package.list,basic.packages)
# remove all extra packages
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
# execute function to keep only basic
# packages in global envir.
detachAllPackages()
# set working directory
# which should be the same for everyone
# assuming GitHub is in your "Documents" folder
setwd("~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)/")
# load libraries
pkgTest <- function(pkg){
# check whether a package is installed
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
# if there are any packeages that need to be installed
if (length(new.pkg))
# install package
install.packages(new.pkg, dependencies = TRUE)
# and then load all packages user listed
sapply(pkg, require, character.only = TRUE)
}
# apply function to load libraries and install them if necessary
lapply(c("stringr", "plyr", "tidyverse", "tidyr", "dplyr"), pkgTest)
#######################
# load dataset of MPs
#######################
# read in your .csv files
# first, check which files are in the working directory
filenames <- gsub("\\.csv$","", list.files(pattern="\\.csv$"))
# iterate over those file names and read each .csv
for(i in filenames){
# Tip: you almost always want to read stringsAsFactors=F in .csv
# because you want to often text as text, not factors
assign(i, read.csv(paste(i, ".csv", sep=""), stringsAsFactors = F, encoding = "UTF-16"))
}
################################
View(canada_commons_members_parl42)
# read in your .csv files
# first, check which files are in the working directory
filenames <- gsub("\\.csv$","", list.files(pattern="\\.csv$"))
# iterate over those file names and read each .csv
for(i in filenames){
# Tip: you almost always want to read stringsAsFactors=F in .csv
# because you want to often text as text, not factors
assign(i, read.csv(paste(i, ".csv", sep=""), stringsAsFactors = F, encoding = "UTF-8"))
}
View(canada_commons_members_parl42)
#######################
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
# create list of basic libraries that are essential
basic.packages <- c("package:stats","package:graphics","package:grDevices",
"package:utils","package:datasets","package:methods","package:base")
# find all packages that are floating in the global environment
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
# make sure that basic packages aren't dropped
package.list <- setdiff(package.list,basic.packages)
# remove all extra packages
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
# execute function to keep only basic
# packages in global envir.
detachAllPackages()
# set working directory
# which should be the same for everyone
# assuming GitHub is in your "Documents" folder
setwd("~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)/")
# load libraries
pkgTest <- function(pkg){
# check whether a package is installed
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
# if there are any packeages that need to be installed
if (length(new.pkg))
# install package
install.packages(new.pkg, dependencies = TRUE)
# and then load all packages user listed
sapply(pkg, require, character.only = TRUE)
}
# apply function to load libraries and install them if necessary
lapply(c("stringr", "plyr", "tidyverse", "tidyr", "dplyr"), pkgTest)
#######################
# load dataset of MPs
#######################
# read in your .csv files
# first, check which files are in the working directory
filenames <- gsub("\\.csv$","", list.files(pattern="\\.csv$"))
# iterate over those file names and read each .csv
for(i in filenames){
# Tip: you almost always want to read stringsAsFactors=F in .csv
# because you want to often text as text, not factors
assign(i, read.csv(paste(i, ".csv", sep=""), stringsAsFactors = F, encoding = "UTF-8"))
}
################################
# load dataset of constituencies
################################
# you'll want this later to merge w/ info from MPs
constituencies <- read.csv("../canada_constituencies.csv", stringsAsFactors = F, encoding = "UTF-8")
########################################
# distinguish b/w parliamentary sessions
########################################
# create a variable denoting which parliamentary session each dataframe is
# this is useful for when we combine the dataframes together by stacking
# them on top of each other by row (see line 89)
# first, create function to go over each dataframe
findNumber <- function(df){
# and grab any numbers in the name of that dataframe
# create that variable and apply value for each row
df$parliamentNumber <- gsub("[^[:digit:].]", "", i)
# return data frame
return(df)
}
# find all data frames in the global environment
globalEnvir <- .GlobalEnv
# iterate over all those data frame
for(i in filenames){
# apply function to each data frame in global environment
globalEnvir[[i]] <- findNumber(globalEnvir[[i]])
}
# can always check to make sure it worked
# ex; look at canada_commons_members_parl40$parliamentNumber
#############################
# create one large dataframe
#############################
# stack dataframes on top of each other
# to create one large dataframe
allMPs <- do.call(rbind, mget(filenames))
###################################
### clean names, dates, and parties
###################################
# rename variables to match codebook
names(allMPs) <- c("title", "first_name", "last_name", "constituency_name",
"province_name", "party_name", "start_date", "end_date", "parliament_number")
# INPUT:
# (1) data frame that dates are in
# (2) name of column with start dates (start_date)
# (3) name of column with end dates (end_date)
# OUTPUT:
# start_year, start_month, start_day
# end_year, end_month, end_day
cleanDates <- function(df, start, end){
# remove timestamp from string
# removing leading "20" in some year dates
# converting all to prefered date object and format
#browser()
df[,start] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,start])), "%m/%d/%y")
df[,end] <- as.Date(gsub('20', '' , gsub('([0-9]+) .*', '\\1', df[,end])), "%m/%d/%y")
# clean party names
df$party_name[df$party_name == "Conservative"] <- "Conservative Party of Canada"
df$party_name[df$party_name == "Liberal"] <- "Liberal Party of Canada"
df$party_name[df$party_name == "NDP"] <- "New Democratic Party"
df$party_name[df$party_name == "Green Party"] <- "Green Party of Canada"
# fix constituency name
df$constituency_name[df$constituency_name == "Western Arctic"] <- "Northwest Territories"
# drop title
df$title <- NULL
# chamber name
df$chamber_name <- "House of Commons"
# full name
df$full_name <- str_c(df$first_name, df$last_name, sep = " ")
# drop those observations missing first names
df <-  filter(df, first_name != "")
return(df)
}
allMPs <- cleanDates(allMPs, "start_date", "end_date")
#############
# set working directory
# load data
# and load libraries
#######################
# remove objects
rm(list=ls())
# detach all libraries
detachAllPackages <- function() {
# create list of basic libraries that are essential
basic.packages <- c("package:stats","package:graphics","package:grDevices",
"package:utils","package:datasets","package:methods","package:base")
# find all packages that are floating in the global environment
package.list <- search()[ifelse(unlist(gregexpr("package:",search()))==1,TRUE,FALSE)]
# make sure that basic packages aren't dropped
package.list <- setdiff(package.list,basic.packages)
# remove all extra packages
if (length(package.list)>0)  for (package in package.list) detach(package, character.only=TRUE)
}
# execute function to keep only basic
# packages in global envir.
detachAllPackages()
# set working directory
# which should be the same for everyone
# assuming GitHub is in your "Documents" folder
setwd("~/Documents/GitHub/CompLegFall2019/data/canadaTextParsing/Members (CSV)/")
# load libraries
pkgTest <- function(pkg){
# check whether a package is installed
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
# if there are any packeages that need to be installed
if (length(new.pkg))
# install package
install.packages(new.pkg, dependencies = TRUE)
# and then load all packages user listed
sapply(pkg, require, character.only = TRUE)
}
# apply function to load libraries and install them if necessary
lapply(c("stringr", "plyr", "tidyverse", "tidyr", "dplyr"), pkgTest)
#######################
# load dataset of MPs
#######################
# read in your .csv files
# first, check which files are in the working directory
filenames <- gsub("\\.csv$","", list.files(pattern="\\.csv$"))
# iterate over those file names and read each .csv
for(i in filenames){
# Tip: you almost always want to read stringsAsFactors=F in .csv
# because you want to often text as text, not factors
assign(i, read.csv(paste(i, ".csv", sep=""), stringsAsFactors = F, encoding = "UTF-8"))
}
constituencies <- read.csv("../canada_constituencies.csv", stringsAsFactors = F, encoding = "UTF-8")
View(export)
unique(canada_commons_members_parl42$Constituency)
length(unique(canada_commons_members_parl42$Constituency))
>>>>>>> 112f3ac1f919f70c40930d77734580282309686d
